#pragma enable_d3d11_debug_symbols
#pragma kernel StepSimulation
#pragma kernel ComputeTotalEnergy
#pragma kernel ProcessTexture
#pragma kernel RenderMasses

#define threadsX 256 // threads per group
#define G_u 0.0000000000667408 // universal gravitational constant
#define a_b 0.06637 // acceleration due to a 10^30 kg mass at 1 exameter away (10^15 m)
#define particleRadius 6

struct PointMass
{
	float mass; // planned [in 10^30 kilograms]
	float3 position; // planned [in petameters (10^15 meters)]
};

struct Motion
{
	float3 velocity;
	float3 acceleration;
};

RWTexture2D<float4> renderTexture;
RWStructuredBuffer<PointMass> masses : register(u0);
RWStructuredBuffer<Motion> motions : register(u1); 
RWStructuredBuffer<float2> readout : register(u2);

groupshared PointMass threadGroupPointMasses[256]; // thread group shared memory buffer

uint numMasses;
float deltaTime;
float halfDeltaTime;
float3 cameraPosition;
float4x4 worldToScreenMatrix;

inline float3 hueToRGB(float H)
{
	float R = abs(H * 6 - 3) - 1;
	float G = 2 - abs(H * 6 - 2);
	float B = 2 - abs(H * 6 - 4);
	return saturate(float3(R, G, B));
}

[numthreads(threadsX, 1, 1)]
void StepSimulation(uint3 id : SV_DispatchThreadID, uint groupIndex : SV_GroupIndex)
{
	float3 pos = masses[id.x].position;
	Motion m = motions[id.x];
	float3 vel = m.velocity;
	float3 accel = 0;
	
	for (uint i = 0; i < numMasses; i += threadsX) // calculate net acceleration WORKS BETTER
	{
		uint index = groupIndex + i;
		threadGroupPointMasses[groupIndex] = masses[index]; // each thread copies global data into thread memory
		for (uint i2 = 0; i2 < threadsX; ++i2)
		{
			PointMass p = threadGroupPointMasses[i2]; // faster read from thread memory
			float mass = p.mass;
			float3 deltaPos = p.position - pos;
			float3 invDist = rsqrt(dot(deltaPos, deltaPos));
			float3 cubeInverse = invDist * invDist * invDist;
			if (id.x != index)
			{
				accel += deltaPos * (mass * cubeInverse);
			}
		}
	}

	accel *= G_u;

	/* https://gist.github.com/sebbbi/ba4415339b535d22fb18e2d824564ec4
	const uint WAVE_LANES = WaveGetLaneCount();
	const uint WAVE_INDEX = WaveGetLaneIndex();
	
	for (int i = 0; i < numMasses / WAVE_LANES; ++i) // calculate net acceleration
	{
		PointMass p = masses[i * WAVE_LANES + WAVE_INDEX];

		for (uint i2 = 0; i2 < WAVE_LANES; ++i2)
		{
			//PointMass po = WaveReadLaneAt(p, i2);
		}
		float mass = p.mass;
		float3 deltaPos = p.position - pos;
		float3 invDist = rsqrt(dot(deltaPos, deltaPos) + 0.0000f);
		float3 cbInvDist = invDist * invDist * invDist;

		accel += deltaPos * (G_u * mass * cbInvDist);
	}*/

	GroupMemoryBarrierWithGroupSync(); // sync threads before translating masses

	// vel += m.acceleration * halfDeltaTime; // kick-drift-kick integration
	// pos += vel * deltaTime;
	// vel += accel * halfDeltaTime;

	pos += vel * deltaTime + m.acceleration * halfDeltaTime * deltaTime; // velocity Verlet integration
	vel += (m.acceleration + accel) * halfDeltaTime;

	masses[id.x].position = pos; // save state
	m.velocity = vel;
	m.acceleration = accel;
	motions[id.x] = m;
}

[numthreads(128, 1, 1)]
void RenderMasses(uint3 id : SV_DispatchThreadID)
{
	float3 pos = masses[id.x].position;
	float3 vel = motions[id.x].velocity;
	float4 v = mul(worldToScreenMatrix, float4(pos, 1)); // transform world space position to screen space
	float w = v.w;
	v /= w;
	
	float j = (length(vel)-10) * 0.0045;

	float camDist = distance(cameraPosition, pos);
	float4 val =  w > 0 && v.x >= 0 && v.y >= 0 ? float4(hueToRGB(j) * 16 * rsqrt(camDist), 1.0) : 0;
	renderTexture[(float2) v] += val;

	/*
	[unroll((particleRadius + 1) * (particleRadius + 1))]
	for (int i = 0; i < (particleRadius + 1) * (particleRadius + 1); ++i)
	{
		int cx = i / (particleRadius * 2 + 1) - particleRadius;
		int cy = i % (particleRadius * 2 + 1) - particleRadius;
		float cdist = cx * cx + cy * cy;
		float intensity = cdist != 0 ? 0.3 / cdist : 1;
		//float valPresent = length(renderTexture[(float2) v + float2(cx, cy)]);
		renderTexture[(float2) v + float2(cx, cy)] += val * intensity;
		renderTexture[(float2) v + float2(cx, cy)] *= 0.99;	
	}

	/*
	for (int cx = -particleRadius; cx <= particleRadius; ++cx)
	{
		for (int cy = -particleRadius; cy <= particleRadius; ++cy)
		{
			float cdist = cx * cx + cy * cy;
			float intensity = cdist != 0 ? 0.2 / cdist : 1;
			//float valPresent = length(renderTexture[(float2) v + float2(cx, cy)]);
            renderTexture[(float2) v + float2(cx, cy)] += val * intensity;
			renderTexture[(float2) v + float2(cx, cy)] *= 0.99;		
		}
	}*/
	renderTexture[(float2) v + float2(1, 0)] += val * 0.4;
	renderTexture[(float2) v + float2(-1, 0)] += val * 0.4;
	renderTexture[(float2) v + float2(0, 1)] += val * 0.4;
	renderTexture[(float2) v + float2(0, -1)] += val * 0.4;
	
}

[numthreads(128, 1, 1)]
void ComputeTotalEnergy(uint3 id : SV_DispatchThreadID)
{
	PointMass p = masses[id.x];
	float Gm = G_u * p.mass;
	float vel = motions[id.x].velocity;
	float Ekinetic = 0.5f * vel * vel * p.mass;
	float Epotential = 0;
	
	for (uint i = 0; i < numMasses; ++i)
	{
		PointMass po = masses[i];
		float dist = distance(p.position, po.position);
		if (i != id.x)
		{
			Epotential -= Gm * po.mass / dist;
		}
	}

	readout[id.x] = float2(Ekinetic, Epotential);
}


// Fade kernel, subtracts color from all pixels
[numthreads(32, 8, 1)]
void ProcessTexture(uint3 id : SV_DispatchThreadID)
{
	float4 originalValue = renderTexture[id.xy];
	float4 fadedValue = max(0, originalValue - 0.05);
	renderTexture[id.xy] = fadedValue;
}